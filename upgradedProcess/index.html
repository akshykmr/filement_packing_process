<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gemini Smart Factory</title>
  <style>
    :root {
      --color-bg: #1a1a1a;
      --color-panel: #2d2d2d;
      --color-text: #e0e0e0;
      --color-accent: #4ECDC4;
      --color-accent-2: #FF6B6B;
      --color-ai: #c77dff; /* Sparkle Purple */
      --font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }
    
    body { 
      margin: 0; 
      background: var(--color-bg); 
      color: var(--color-text); 
      font-family: var(--font-family);
      overflow: hidden; 
    }

    .container {
      display: flex;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
    }

    /* Left Control Panel */
    .sidebar {
      width: 340px;
      min-width: 340px;
      background: var(--color-panel);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      box-shadow: 2px 0 10px rgba(0,0,0,0.3);
      z-index: 10;
      overflow-y: auto;
    }

    h1 { font-size: 1.2rem; margin: 0 0 10px 0; color: #fff; border-bottom: 2px solid #444; padding-bottom: 10px; }
    h2 { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; color: #888; margin-bottom: 8px; margin-top: 0; }

    .control-group {
      background: rgba(0,0,0,0.2);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #444;
    }
    
    .ai-group {
      background: rgba(81, 45, 168, 0.15);
      border: 1px solid var(--color-ai);
    }

    .ai-title {
      color: var(--color-ai);
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    label { display: block; font-size: 0.85rem; margin-bottom: 5px; }
    
    input[type="range"], input[type="number"] {
      width: 100%;
      background: #444;
      border: 1px solid #555;
      color: white;
      padding: 5px;
      border-radius: 4px;
      box-sizing: border-box;
    }

    .btn-row { display: flex; gap: 10px; }
    
    button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
      font-size: 0.85rem;
    }

    .btn-primary { background: var(--color-accent); color: #000; }
    .btn-primary:hover { background: #3dbdb5; }
    
    .btn-danger { background: var(--color-accent-2); color: #fff; }
    
    .btn-ai { 
      background: var(--color-ai); 
      color: #fff; 
      width: 100%;
      margin-top: 5px;
    }
    .btn-ai:hover { background: #9d4edd; box-shadow: 0 0 10px var(--color-ai); }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 8px;
    }
    
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #444;
      transition: .4s;
      border-radius: 20px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider { background-color: var(--color-ai); }
    input:checked + .slider:before { transform: translateX(20px); }

    /* Weight Log Area */
    .log-container {
      flex: 1;
      background: #000;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      overflow-y: auto;
      max-height: 150px;
      display: flex;
      flex-direction: column-reverse; 
    }
    
    .ai-output {
      margin-top: 10px;
      background: #111;
      border-left: 3px solid var(--color-ai);
      padding: 8px;
      font-size: 0.8rem;
      color: #d0bfff;
      min-height: 40px;
      max-height: 100px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    .log-entry {
      border-bottom: 1px solid #333;
      padding: 4px 0;
      display: flex;
      justify-content: space-between;
    }
    .log-entry.left { color: var(--color-accent-2); }
    .log-entry.right { color: var(--color-accent); }
    .ai-tag { font-size: 0.7rem; color: var(--color-ai); font-style: italic; }

    /* 3D Canvas Area */
    .main-view {
      flex: 1;
      position: relative;
      background: #1a1a1a;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    #machine-canvas {
      width: 100%;
      height: 100%;
      display: block;
      outline: none;
    }

    /* HUD Overlay */
    .hud {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 8px;
      pointer-events: none;
      z-index: 100;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      background: #444;
      font-size: 0.8rem;
      font-weight: bold;
      margin-top: 5px;
    }

    .highlight-text { color: var(--color-accent); }
    
    /* Loading Spinner */
    .spinner {
      display: inline-block;
      width: 10px;
      height: 10px;
      border: 2px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin-left: 5px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <div class="container">
    <!-- Sidebar Controls -->
    <div class="sidebar">
      <div>
        <h1>System Control</h1>
        <p style="font-size: 0.8rem; color: #888;">Dual-Arm Packaging & AI Analysis</p>
      </div>

      <!-- New AI Panel -->
      <div class="control-group ai-group">
        <h2 class="ai-title">âœ¨Smart Report Generator</h2>
        
        <!-- <div class="toggle-row">
          <label style="margin:0; cursor:pointer;" for="aiBrandingToggle">AI Auto-Labeling</label>
          <label class="switch">
            <input type="checkbox" id="aiBrandingToggle">
            <span class="slider"></span>
          </label>
        </div> -->
        <p style="font-size: 0.7rem; color: #aaa; margin-bottom: 10px;">Generates creative names for bundles.</p>
        
        <button id="analyzeBtn" class="btn-ai">âœ¨ Analyze Shift Report</button>
        <div id="aiOutput" class="ai-output" style="display:none;">Waiting for report...</div>
      </div>

      <div class="control-group">
        <h2>Operations</h2>
        <div class="btn-row">
          <button id="playPause" class="btn-primary">Pause</button>
          <button id="resetBtn" class="btn-danger">Reset</button>
        </div>
        <div style="margin-top: 10px;">
          <label>Simulation Speed: <span id="speed-value">1.0x</span></label>
          <input type="range" min="0.5" max="3" step="0.1" id="speed" value="1">
        </div>
      </div>

      <div class="control-group">
        <h2>Material Specs</h2>
        <div style="margin-bottom: 10px;">
          <label style="color: var(--color-accent-2);">Left Arm Height (cm)</label>
          <input type="number" id="leftHeightInput" value="80" min="40" max="120" step="1">
        </div>
        <div>
          <label style="color: var(--color-accent);">Right Arm Height (cm)</label>
          <input type="number" id="rightHeightInput" value="60" min="40" max="120" step="1">
        </div>
        <button id="updateSizeBtn" style="width: 100%; margin-top: 10px; background: #555; color: white;">Apply New Sizes</button>
      </div>

      <div class="control-group" style="display: flex; flex-direction: column; flex: 1;">
        <h2>Production Log (100g - 120g)</h2>
        <div id="weightLog" class="log-container">
          <div class="log-entry" style="color: #666; justify-content: center;">System initialized...</div>
        </div>
      </div>
    </div>

    <!-- 3D Viewport -->
    <div class="main-view">
      <div class="hud">
        <div style="font-size: 1.5rem; font-weight: bold;">Cycle Time: <span id="cycleTimer" class="highlight-text">0.0s</span></div>
        <div class="status-badge" id="cycleText">Initializing...</div>
        <div style="margin-top: 10px;">
          ðŸ“¦ Total Packed: <span id="cycleCount">0</span>
        </div>
      </div>
      <canvas id="machine-canvas"></canvas>
    </div>
  </div>

  <!-- Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Combined Application Logic -->
  <script>
    // ===== GEMINI API CONFIGURATION =====
    const apiKey = ""; // Runtime Environment will provide key
    
    async function callGemini(prompt) {
      try {
        const response = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{ parts: [{ text: prompt }] }]
            })
          }
        );
        
        if (!response.ok) throw new Error("API Error");
        const data = await response.json();
        return data.candidates[0].content.parts[0].text;
      } catch (e) {
        console.error("Gemini Error:", e);
        return "AI Service Unavailable";
      }
    }

    // ===== SIMULATION CONFIGURATION =====
    const MACHINE_CONFIG = {
      // Input Stations (Back of the scene)
      leftInput: { x: -2, y: 0, z: -5, color: '#444444' },
      rightInput: { x: 2, y: 0, z: -5, color: '#444444' },
      
      // Center Base
      centerBase: { radius: 1.5, height: 0.6, color: '#333' },
      
      // Arms
      leftArm: { pivotX: -2.0, pivotY: 0.6, pivotZ: 0, color: '#FF6B6B' },
      rightArm: { pivotX: 2.0, pivotY: 0.6, pivotZ: 0, color: '#4ECDC4' },
      
      // Processing Stations~
      leftWrapper: { x: -6.5, y: 0, z: 0, color: '#2E7D32' },
      rightWrapper: { x: 6.5, y: 0, z: 0, color: '#2E7D32' },
      
      leftPaperMachine: { x: -5, y: 0, z: 3, color: '#F57F17' },
      rightPaperMachine: { x: 5, y: 0, z: 3, color: '#F57F17' },
      
      leftTray: { x: -3, y: 0.1, z: 6, width: 3.5, depth: 2.5 },
      rightTray: { x: 3, y: 0.1, z: 6, width: 3.5, depth: 2.5 },

      baseRadius: 0.35,
      leftHeight: 0.8,
      rightHeight: 0.6
    };

    // TIMELINE - REVISED FOR SPECIFIC ARM MOVEMENTS
    // Angle 0 = Points to Back (Input)
    // Angle PI = Points to Front (Output)
    const CYCLE_DURATION = 18.0; 
    const PHASES = [
      { name: 'spawn_at_start', start: 0.0, end: 1.0, label: 'ðŸ­ Spawning at Input Station' },
      { name: 'pick_input', start: 1.0, end: 3.0, label: 'ðŸ¦¾ Picking Material (Arms at Input)' },
      { name: 'move_wrap', start: 3.0, end: 5.0, label: 'âž¡ï¸ Rotating to Wrapper' },
      { name: 'wait_wrap', start: 5.0, end: 8.0, label: 'â³ Waiting for Wrapping' },
      { name: 'move_paper', start: 8.0, end: 10.0, label: 'âž¡ï¸ Rotating to Paper Station' },
      { name: 'wait_paper', start: 10.0, end: 13.0, label: 'â³ Waiting for Paper Application' },
      { name: 'move_output', start: 13.0, end: 15.0, label: 'âž¡ï¸ Rotating to Output' },
      { name: 'drop_item', start: 15.0, end: 16.0, label: 'ðŸ“¦ Dropping Item' },
      { name: 'return_home', start: 16.0, end: 18.0, label: 'ðŸ”„ Rotating BACK to Input' }
    ];

    // GLOBALS
    let scene, camera, renderer, controls, clock;
    let isPaused = false;
    let speed = 1.0;
    let cycleTime = 0;
    let totalCycles = 0;
    let loggedWeights = []; // Store for AI Analysis

    // MACHINE STATE
    let machine = {
      leftArmGroup: null, rightArmGroup: null,
      leftGripper: null, rightGripper: null,
      leftJaws: [], rightJaws: [],
      leftObject: null, rightObject: null,
      leftObjState: 'loose', rightObjState: 'loose',
      leftFinishedItems: [], rightFinishedItems: [] 
    };

    // DOM ELEMENTS
    const ui = {
      timer: document.getElementById('cycleTimer'),
      status: document.getElementById('cycleText'),
      count: document.getElementById('cycleCount'),
      log: document.getElementById('weightLog'),
      leftHeight: document.getElementById('leftHeightInput'),
      rightHeight: document.getElementById('rightHeightInput'),
      aiToggle: document.getElementById('aiBrandingToggle'),
      aiOutput: document.getElementById('aiOutput'),
      analyzeBtn: document.getElementById('analyzeBtn')
    };

    // INITIALIZATION
    function init() {
      const canvas = document.getElementById('machine-canvas');
      
      if(!canvas) return;

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(canvas.clientWidth || window.innerWidth, canvas.clientHeight || window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);
      
      camera = new THREE.PerspectiveCamera(45, (canvas.clientWidth || 1) / (canvas.clientHeight || 1), 0.1, 100);
      camera.position.set(0, 15, 20);
      camera.lookAt(0, 0, 0);

      controls = new THREE.OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.maxPolarAngle = Math.PI / 2.1;

      setupLights();
      buildEnvironment();
      buildRobots();
      
      window.addEventListener('resize', onResize);
      document.getElementById('playPause').addEventListener('click', togglePause);
      document.getElementById('resetBtn').addEventListener('click', resetSim);
      document.getElementById('updateSizeBtn').addEventListener('click', updateSizes);
      document.getElementById('speed').addEventListener('input', (e) => {
        speed = parseFloat(e.target.value);
        document.getElementById('speed-value').innerText = speed.toFixed(1) + 'x';
      });
      
      ui.analyzeBtn.addEventListener('click', generateShiftReport);

      clock = new THREE.Clock();
      
      // CORRECT INITIAL STATE: Arms point to Back/Input (Angle 0)
      rotateArm(machine.leftArmGroup, 0); 
      rotateArm(machine.rightArmGroup, 0);

      onResize();
      setTimeout(onResize, 100);
      
      animate();
    }

    // AI FUNCTION: Shift Report
    async function generateShiftReport() {
      if (loggedWeights.length === 0) {
        ui.aiOutput.style.display = 'block';
        ui.aiOutput.innerText = "No production data yet. Wait for bundles to complete.";
        return;
      }

      ui.aiOutput.style.display = 'block';
      ui.aiOutput.innerHTML = 'Analyzing... <div class="spinner"></div>';
      
      const weightsStr = loggedWeights.map(w => w.weight + 'g').join(', ');
      const prompt = `
        I am a factory manager. Here is the list of recent filament bundle weights produced by the Dual-Arm system:
        [${weightsStr}]
        
        The target range is 100g to 120g.
        Please provide a concise, professional Quality Control Report (max 3 sentences).
        Summarize the consistency, calculate average efficiency, and mention if calibration is needed.
      `;
      
      const result = await callGemini(prompt);
      ui.aiOutput.innerText = result;
    }

    // AI FUNCTION: Auto Branding
    async function getBrandName(weight, side) {
      const prompt = `Create a short, cool, industrial sci-fi product code name for a filament bundle weighing ${weight}g. Return ONLY the name (e.g. "Titan-X"). No formatting.`;
      const name = await callGemini(prompt);
      
      const entries = document.querySelectorAll(`.log-entry.${side}`);
      if (entries.length > 0) {
        const latest = entries[0]; 
        const span = document.createElement('span');
        span.className = 'ai-tag';
        span.innerText = `âœ¨ ${name}`;
        latest.appendChild(span);
      }
    }

    function setupLights() {
      const amb = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(amb);
      
      const dir = new THREE.DirectionalLight(0xffffff, 1);
      dir.position.set(10, 20, 10);
      dir.castShadow = true;
      dir.shadow.mapSize.width = 2048;
      dir.shadow.mapSize.height = 2048;
      scene.add(dir);
      
      const spot = new THREE.SpotLight(0x4ECDC4, 0.5);
      spot.position.set(0, 10, 0);
      scene.add(spot);
    }

    function createLooseMaterial(height, color) {
      const group = new THREE.Group();
      const geo = new THREE.CylinderGeometry(0.3, 0.35, height, 8);
      const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true, transparent: true, opacity: 0.6 });
      const core = new THREE.Mesh(geo, mat);
      group.add(core);
      for(let i=0; i<8; i++) {
        const sGeo = new THREE.BoxGeometry(0.05, height * 0.9, 0.05);
        const sMat = new THREE.MeshStandardMaterial({ color: color });
        const s = new THREE.Mesh(sGeo, sMat);
        s.position.set((Math.random()-0.5)*0.6, 0, (Math.random()-0.5)*0.6);
        s.rotation.set(0, Math.random()*Math.PI, (Math.random()-0.5)*0.2);
        group.add(s);
      }
      group.castShadow = true;
      return group;
    }

    function createBundledMaterial(height, color) {
      const geo = new THREE.CylinderGeometry(0.35, 0.35, height, 32);
      const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4, metalness: 0.1 });
      const mesh = new THREE.Mesh(geo, mat);
      const band = new THREE.Mesh(new THREE.TorusGeometry(0.36, 0.05, 8, 32), new THREE.MeshStandardMaterial({ color: 0xffd700 }));
      band.rotation.x = Math.PI / 2;
      mesh.add(band);
      mesh.castShadow = true;
      return mesh;
    }

    function createPaperPackage(height) {
      const geo = new THREE.CylinderGeometry(0.38, 0.38, height + 0.1, 32);
      const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
      const mesh = new THREE.Mesh(geo, mat);
      const label = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.2), new THREE.MeshBasicMaterial({ color: 0x333333 }));
      label.position.set(0, 0, 0.39);
      mesh.add(label);
      mesh.castShadow = true;
      return mesh;
    }

    function buildEnvironment() {
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }));
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);
      scene.add(new THREE.GridHelper(30, 30, 0x444444, 0x111111));
      
      buildStation(MACHINE_CONFIG.leftInput, "Left Input");
      buildStation(MACHINE_CONFIG.rightInput, "Right Input");
      buildMachineBox(MACHINE_CONFIG.leftWrapper, "Wrapper");
      buildMachineBox(MACHINE_CONFIG.rightWrapper, "Wrapper");
      buildTunnelMachine(MACHINE_CONFIG.leftPaperMachine, "Paper wrapping");
      buildTunnelMachine(MACHINE_CONFIG.rightPaperMachine, "Paper wrappings");
      buildTray(MACHINE_CONFIG.leftTray, "Left Output");
      buildTray(MACHINE_CONFIG.rightTray, "Right Output");
    }

    function buildStation(cfg, text) {
      const m = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 2), new THREE.MeshStandardMaterial({ color: cfg.color }));
      m.position.set(cfg.x, 0.25, cfg.z);
      m.receiveShadow = true;
      scene.add(m);
      addLabel(cfg.x, 2, cfg.z, text);
    }

    function buildMachineBox(cfg, text) {
      const g = new THREE.Group();
      const b = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), new THREE.MeshStandardMaterial({ color: cfg.color }));
      b.position.y = 0.75;
      g.add(b);
      const s = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.2, 16), new THREE.MeshStandardMaterial({ color: 0x888888 }));
      s.position.y = 1.6;
      g.add(s);
      g.position.set(cfg.x, 0, cfg.z);
      scene.add(g);
      addLabel(cfg.x, 2.5, cfg.z, text);
    }

    function buildTunnelMachine(cfg, text) {
      const g = new THREE.Group();
      const a = new THREE.Mesh(new THREE.TorusGeometry(1, 0.2, 8, 16, Math.PI), new THREE.MeshStandardMaterial({ color: cfg.color }));
      a.rotation.y = Math.PI/2; a.position.y = 1;
      g.add(a);
      const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 2.5), new THREE.MeshStandardMaterial({ color: 0x444444 }));
      b.position.y = 0.5;
      g.add(b);
      g.position.set(cfg.x, 0, cfg.z);
      scene.add(g);
      addLabel(cfg.x, 2.5, cfg.z, text);
    }

    function buildTray(cfg, text) {
      const t = new THREE.Mesh(new THREE.BoxGeometry(cfg.width, 0.2, cfg.depth), new THREE.MeshStandardMaterial({ color: 0x8D6E63 }));
      t.position.set(cfg.x, 0.1, cfg.z);
      t.receiveShadow = true;
      scene.add(t);
      addLabel(cfg.x, 1, cfg.z, text);
    }

    function addLabel(x, y, z, text) {
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d');
      c.width = 256; c.height = 64;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,256,64);
      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, 128, 32);
      const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(c), transparent: true }));
      s.position.set(x, y, z);
      s.scale.set(3, 0.75, 1);
      scene.add(s);
    }

    function buildRobots() {
      const base = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.6, 32), new THREE.MeshStandardMaterial({ color: MACHINE_CONFIG.centerBase.color }));
      base.position.y = 0.3;
      scene.add(base);
      machine.leftArmGroup = buildArm(MACHINE_CONFIG.leftArm);
      machine.rightArmGroup = buildArm(MACHINE_CONFIG.rightArm);
    }

    function buildArm(cfg) {
      const g = new THREE.Group();
      g.position.set(cfg.pivotX, cfg.pivotY, cfg.pivotZ);
      const a1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 2.5), new THREE.MeshStandardMaterial({ color: cfg.color }));
      a1.position.z = -1.25;
      g.add(a1);
      const a2 = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 2.0), new THREE.MeshStandardMaterial({ color: '#ffffff' }));
      a2.position.z = -3.5;
      g.add(a2);
      const grip = new THREE.Group();
      grip.position.z = -4.6;
      g.add(grip);
      const jGeo = new THREE.BoxGeometry(0.1, 0.2, 0.4);
      const jMat = new THREE.MeshStandardMaterial({ color: '#333' });
      const jL = new THREE.Mesh(jGeo, jMat); jL.position.x = -0.2;
      const jR = new THREE.Mesh(jGeo, jMat); jR.position.x = 0.2;
      grip.add(jL); grip.add(jR);
      if(cfg === MACHINE_CONFIG.leftArm) { machine.leftGripper = grip; machine.leftJaws = [jL, jR]; }
      else { machine.rightGripper = grip; machine.rightJaws = [jL, jR]; }
      scene.add(g);
      return g;
    }

    function updateSizes() {
      MACHINE_CONFIG.leftHeight = parseInt(ui.leftHeight.value) / 100;
      MACHINE_CONFIG.rightHeight = parseInt(ui.rightHeight.value) / 100;
      const btn = document.getElementById('updateSizeBtn');
      const old = btn.innerText;
      btn.innerText = "Updated!";
      setTimeout(() => btn.innerText = old, 1000);
    }

    function logWeight(side, weight) {
      loggedWeights.push({ side, weight, timestamp: Date.now() });
      
      const div = document.createElement('div');
      div.className = `log-entry ${side}`;
      div.innerHTML = `<span>${side.toUpperCase()}: ${weight}g</span>`;
      ui.log.prepend(div);
      
      if(ui.aiToggle.checked) {
        const span = document.createElement('span');
        span.className = 'ai-tag';
        span.innerText = 'âœ¨ thinking...';
        div.appendChild(span);
        getBrandName(weight, side);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (!isPaused) {
        cycleTime += dt * speed;
        const loopTime = cycleTime % CYCLE_DURATION;
        ui.timer.innerText = loopTime.toFixed(1) + 's';
        const phase = PHASES.find(p => loopTime >= p.start && loopTime < p.end);
        if(phase) {
          ui.status.innerText = phase.label;
          processPhase(phase, loopTime);
        }
      }
      controls.update();
      renderer.render(scene, camera);
    }

    function getTrayPosition(index, side) {
        const cols = 3;
        const col = index % cols;
        const row = Math.floor(index / cols);
        const xOffset = (col - 1) * 0.8;
        const zOffset = (row * 0.8) - 0.8; 
        return { x: xOffset, z: zOffset };
    }

    function processPhase(phase, time) {
      const localT = (time - phase.start) / (phase.end - phase.start);
      const ease = t => t<.5 ? 2*t*t : -1+(4-2*t)*t;
      
      // ANGLE MAPPING:
      // 0 = Pointing Back (Input Station)
      // PI/2 (Left) or -PI/2 (Right) = Pointing Side (Wrapper)
      // PI = Pointing Front (Output Station)

      switch(phase.name) {
        case 'spawn_at_start':
          // Arms stay at Input (Angle 0)
          rotateArm(machine.leftArmGroup, 0);
          rotateArm(machine.rightArmGroup, 0);
          operateGripper(machine.leftJaws, true); 
          operateGripper(machine.rightJaws, true);

          if(localT > 0.1 && !machine.leftObject) {
            machine.leftObject = createLooseMaterial(MACHINE_CONFIG.leftHeight, '#FF8E72');
            machine.leftObject.position.set(MACHINE_CONFIG.leftInput.x, 0.8, MACHINE_CONFIG.leftInput.z);
            scene.add(machine.leftObject);
            machine.leftObjState = 'loose';
          }
          if(localT > 0.1 && !machine.rightObject) {
            machine.rightObject = createLooseMaterial(MACHINE_CONFIG.rightHeight, '#45B7AA');
            machine.rightObject.position.set(MACHINE_CONFIG.rightInput.x, 0.8, MACHINE_CONFIG.rightInput.z);
            scene.add(machine.rightObject);
            machine.rightObjState = 'loose';
          }
          break;
          
        case 'pick_input':
          if(localT > 0.5) {
             operateGripper(machine.leftJaws, false);
             operateGripper(machine.rightJaws, false);
             if(machine.leftObject && machine.leftObject.parent === scene) {
               machine.leftGripper.attach(machine.leftObject);
               machine.leftObject.position.set(0, 0, 0);
             }
             if(machine.rightObject && machine.rightObject.parent === scene) {
               machine.rightGripper.attach(machine.rightObject);
               machine.rightObject.position.set(0, 0, 0);
             }
          }
          break;

        case 'move_wrap':
          // From 0 (Back) to Side
          // Left: 0 -> PI/2
          // Right: 0 -> -PI/2
          rotateArm(machine.leftArmGroup, lerp(0, Math.PI / 2, ease(localT)));
          rotateArm(machine.rightArmGroup, lerp(0, -Math.PI / 2, ease(localT)));
          
          if(localT > 0.9) {
            if(machine.leftObject) {
              scene.attach(machine.leftObject);
              machine.leftObject.position.set(MACHINE_CONFIG.leftWrapper.x, 1.6, MACHINE_CONFIG.leftWrapper.z);
              machine.leftObject.rotation.set(0,0,0);
            }
            if(machine.rightObject) {
              scene.attach(machine.rightObject);
              machine.rightObject.position.set(MACHINE_CONFIG.rightWrapper.x, 1.6, MACHINE_CONFIG.rightWrapper.z);
              machine.rightObject.rotation.set(0,0,0);
            }
          }
          break;

        case 'wait_wrap':
          operateGripper(machine.leftJaws, true);
          operateGripper(machine.rightJaws, true);
          
          if(localT > 0.1 && machine.leftObjState === 'loose') {
            swapGeometry('left', createBundledMaterial(MACHINE_CONFIG.leftHeight, '#CD853F'));
            machine.leftObjState = 'bundled';
          }
          if(localT > 0.1 && machine.rightObjState === 'loose') {
            swapGeometry('right', createBundledMaterial(MACHINE_CONFIG.rightHeight, '#CD853F'));
            machine.rightObjState = 'bundled';
          }
          
          const shake = 0.05;
          if(machine.leftObject) {
            machine.leftObject.position.x = MACHINE_CONFIG.leftWrapper.x + (Math.random()-0.5)*shake;
            machine.leftObject.rotation.y += 0.2;
          }
          if(machine.rightObject) {
            machine.rightObject.position.x = MACHINE_CONFIG.rightWrapper.x + (Math.random()-0.5)*shake;
            machine.rightObject.rotation.y += 0.2;
          }
          break;

        case 'move_paper':
          if(localT < 0.2) {
             operateGripper(machine.leftJaws, false);
             operateGripper(machine.rightJaws, false);
             if(machine.leftObject) machine.leftGripper.attach(machine.leftObject);
             if(machine.rightObject) machine.rightGripper.attach(machine.rightObject);
          }
          
          // From Side to Paper (Front-ish)
          // Left: PI/2 -> 3*PI/4
          // Right: -PI/2 -> -3*PI/4
          rotateArm(machine.leftArmGroup, lerp(Math.PI/2, 3*Math.PI/4, ease(localT)));
          rotateArm(machine.rightArmGroup, lerp(-Math.PI/2, -3*Math.PI/4, ease(localT)));
          
          if(localT > 0.9) {
            if(machine.leftObject) {
              scene.attach(machine.leftObject);
              machine.leftObject.position.set(MACHINE_CONFIG.leftPaperMachine.x, 1.2, MACHINE_CONFIG.leftPaperMachine.z);
            }
            if(machine.rightObject) {
              scene.attach(machine.rightObject);
              machine.rightObject.position.set(MACHINE_CONFIG.rightPaperMachine.x, 1.2, MACHINE_CONFIG.rightPaperMachine.z);
            }
          }
          break;

        case 'wait_paper':
          operateGripper(machine.leftJaws, true);
          operateGripper(machine.rightJaws, true);

          if(localT > 0.5 && machine.leftObjState === 'bundled') {
            swapGeometry('left', createPaperPackage(MACHINE_CONFIG.leftHeight));
            machine.leftObjState = 'paper';
          }
          if(localT > 0.5 && machine.rightObjState === 'bundled') {
            swapGeometry('right', createPaperPackage(MACHINE_CONFIG.rightHeight));
            machine.rightObjState = 'paper';
          }
          break;

        case 'move_output':
          if(localT < 0.2) {
             operateGripper(machine.leftJaws, false);
             operateGripper(machine.rightJaws, false);
             if(machine.leftObject) machine.leftGripper.attach(machine.leftObject);
             if(machine.rightObject) machine.rightGripper.attach(machine.rightObject);
          }
          
          // From Paper to Front (Output)
          // Left: 3*PI/4 -> PI
          // Right: -3*PI/4 -> -PI
          rotateArm(machine.leftArmGroup, lerp(3*Math.PI/4, Math.PI, ease(localT)));
          rotateArm(machine.rightArmGroup, lerp(-3*Math.PI/4, -Math.PI, ease(localT)));
          break;

        case 'drop_item':
          if(localT < 0.1) {
            if(machine.leftObject && machine.leftObject.parent !== scene) {
              scene.attach(machine.leftObject);
              const pos = getTrayPosition(machine.leftFinishedItems.length, 'left');
              machine.leftObject.position.set(MACHINE_CONFIG.leftTray.x + pos.x, 0.4, MACHINE_CONFIG.leftTray.z + pos.z);
              machine.leftObject.rotation.set(Math.PI/2, 0, 0); 
              
              const w = (Math.random() * 20 + 100).toFixed(2);
              logWeight('left', w);
              machine.leftFinishedItems.push(machine.leftObject);
              machine.leftObject = null;
            }
            
            if(machine.rightObject && machine.rightObject.parent !== scene) {
              scene.attach(machine.rightObject);
              const pos = getTrayPosition(machine.rightFinishedItems.length, 'right');
              machine.rightObject.position.set(MACHINE_CONFIG.rightTray.x - pos.x, 0.4, MACHINE_CONFIG.rightTray.z + pos.z);
              machine.rightObject.rotation.set(Math.PI/2, 0, 0);
              
              const w = (Math.random() * 20 + 100).toFixed(2);
              logWeight('right', w);
              machine.rightFinishedItems.push(machine.rightObject);
              machine.rightObject = null;
            }
            ui.count.innerText = totalCycles * 2 + 2;
          }
          break;

        case 'return_home':
          // Return from Front (PI) to Back (0)
          // Left: PI -> 0 (via CCW if we wrap, or simply decrease angle)
          // To visualize "Return" cleanly, simply linearly interpolate back to 0
          operateGripper(machine.leftJaws, true); 
          operateGripper(machine.rightJaws, true);
          
          rotateArm(machine.leftArmGroup, lerp(Math.PI, 0, ease(localT)));
          rotateArm(machine.rightArmGroup, lerp(-Math.PI, 0, ease(localT)));
          
          if(localT > 0.9) totalCycles++;
          break;
      }
    }

    function lerp(start, end, t) { return start * (1 - t) + end * t; }
    function rotateArm(group, angleY) { if(group) group.rotation.y = angleY; }
    function operateGripper(jaws, open) {
      const xPos = open ? 0.3 : 0.15;
      jaws[0].position.x = -xPos; jaws[1].position.x = xPos;
    }
    function swapGeometry(side, newMesh) {
      const oldMesh = side === 'left' ? machine.leftObject : machine.rightObject;
      if(!oldMesh) return;
      newMesh.position.copy(oldMesh.position); newMesh.rotation.copy(oldMesh.rotation);
      scene.remove(oldMesh); scene.add(newMesh);
      if(side === 'left') machine.leftObject = newMesh;
      else machine.rightObject = newMesh;
    }
    function togglePause() {
      isPaused = !isPaused;
      document.getElementById('playPause').innerText = isPaused ? "Resume" : "Pause";
    }
    function resetSim() {
      cycleTime = 0; totalCycles = 0; loggedWeights = [];
      ui.count.innerText = '0'; ui.log.innerHTML = ''; ui.aiOutput.style.display = 'none';
      if(machine.leftObject) scene.remove(machine.leftObject);
      if(machine.rightObject) scene.remove(machine.rightObject);
      
      machine.leftFinishedItems.forEach(item => scene.remove(item));
      machine.rightFinishedItems.forEach(item => scene.remove(item));
      
      machine.leftFinishedItems = [];
      machine.rightFinishedItems = [];
      
      machine.leftObject = null; machine.rightObject = null;
      rotateArm(machine.leftArmGroup, 0); 
      rotateArm(machine.rightArmGroup, 0);
    }
    function onResize() {
      const canvas = document.getElementById('machine-canvas');
      if(!canvas) return;
      
      const width = canvas.parentElement ? canvas.parentElement.clientWidth : window.innerWidth;
      const height = canvas.parentElement ? canvas.parentElement.clientHeight : window.innerHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    init();
  </script>
</body>
</html>